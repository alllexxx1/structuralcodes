"""Classes for integrating the response of sections."""
import abc
import typing as t

from numpy.typing import ArrayLike

from ._generic import CompoundGeometry


class SectionIntegrator(abc.ABC):
    """Abstract base class for section integrators."""

    @abc.abstractmethod
    def prepare_input(self, geo: CompoundGeometry, strain: ArrayLike):
        """Prepare general input to the integration method.

        Args:
            geo (CompoundGeometry): The geometry to integrate over.
            strain (ArrayLike): The scalar strain components necessary for
                describing the assumed strain distribution over the geometry.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def integrate(self, *prepared_input, **kwargs) -> float:
        """Integrate stresses over the gemetry.

        The input to this method is generated by the prepare_input method. It
        also takes kwargs depending on the concrete implementation.

        Arguments:
            *prepared_input: The input prepared by the prepare_input method.

        Keyword Arguments:
            **kwargs: Keyword arguments depending on the concrete
                implementation.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def integrate_strain_response_on_geometry(
        self, geo: CompoundGeometry, strain: ArrayLike
    ):
        """Integrate over the geometry to obtain the response due to strains."""
        raise NotImplementedError


class MarinIntegrator(SectionIntegrator):
    """Section integrator based on the Marin algorithm."""

    def prepare_input(
        self, geo: CompoundGeometry, strain: ArrayLike
    ) -> t.Tuple[ArrayLike, ArrayLike]:
        """Prepare general input to the integration.

        Calculate the stresses based on strains in a set of points.

        Args:
            geo (CompoundGeometry): The geometry of the section.
            strain (ArrayLike): The strains and curvatures of the section.
        """
        raise NotImplementedError

    def integrate(
        self,
        coordinates: ArrayLike,
        stresses: ArrayLike,
        x_exponent: t.Literal[0, 1],
        y_exponent: t.Literal[0, 1],
    ) -> float:
        """Integrate stresses over the geometry."""
        raise NotImplementedError

    def integrate_strain_response_on_geometry(
        self, geo: CompoundGeometry, strain: ArrayLike
    ):
        """Integrate the strain response with the Marin algorithm."""
        # Prepare the general input based on the geometry and the input strains
        prepared_input = self.prepare_input(geo, strain)

        # Calculate the axial forces
        N = self.integrate(*prepared_input, x_exponent=0, y_exponent=1)
        Mx = self.integrate(*prepared_input, x_exponent=0, y_exponent=1)
        My = self.integrate(*prepared_input, x_exponent=1, y_exponent=0)

        return N, Mx, My


integrator_registry = {'Marin': MarinIntegrator}


class IntegratorFactory:
    """A factory for integrators."""

    instances: t.Dict  # A dict of integrators that have been created.
    registry: t.Dict[str, SectionIntegrator]

    def __init__(self, registry: t.Dict[str, SectionIntegrator]):
        self.instances = {}
        self.registry = registry

    def __call__(self, method: str) -> SectionIntegrator:
        """Create an integrator based on its name."""
        self.instances.setdefault(
            method, self.registry.get(method, MarinIntegrator)
        )
        # Here we should throw a warning if the user input an integrator not
        # given in the registry.
        return self.instances.get(method)


integrator_factory = IntegratorFactory(integrator_registry)
