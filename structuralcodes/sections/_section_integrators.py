"""Classes for integrating the response of sections."""

import abc
import typing as t

import numpy as np
from numpy.typing import ArrayLike

from math import atan2, cos, sin

from shapely.geometry.polygon import orient
from shapely import MultiLineString, Polygon, MultiPolygon

import triangle

from structuralcodes.geometry import (
    create_line_point_angle,
    CompoundGeometry,
    SurfaceGeometry,
)
from ._marin_integration import marin_integration


class SectionIntegrator(abc.ABC):
    """Abstract base class for section integrators."""

    @abc.abstractmethod
    def prepare_input(self, geo: CompoundGeometry, strain: ArrayLike):
        """Prepare general input to the integration method.

        Args:
            geo (CompoundGeometry): The geometry to integrate over.
            strain (ArrayLike): The scalar strain components necessary for
                describing the assumed strain distribution over the geometry.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def integrate(self, *prepared_input, **kwargs) -> float:
        """Integrate stresses over the gemetry.

        The input to this method is generated by the prepare_input method. It
        also takes kwargs depending on the concrete implementation.

        Arguments:
            *prepared_input: The input prepared by the prepare_input method.

        Keyword Arguments:
            **kwargs: Keyword arguments depending on the concrete
                implementation.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def integrate_strain_response_on_geometry(
        self, geo: CompoundGeometry, strain: ArrayLike, **kwargs
    ):
        """Integrate over the geometry to obtain the response due
        to strains.
        """
        raise NotImplementedError


class MarinIntegrator(SectionIntegrator):
    """Section integrator based on the Marin algorithm."""

    def prepare_input(
        self, geo: CompoundGeometry, strain: ArrayLike
    ) -> t.Tuple[t.Tuple[np.ndarray, np.ndarray, np.ndarray]]:
        """Prepare general input to the integration.

        Calculate the stresses based on strains in a set of points.

        Args:
            geo (CompoundGeometry): The geometry of the section.
            strain (ArrayLike): The strains and curvatures of the section.
                                given in the format (ea, ky, kz) which are
                                strain at 0,0
                                curvature y axis
                                curvature z axis
        """
        # This method should do the following tasks:
        # - For each geo:
        #   - ask constitutive law strain limits and coefficients
        #   - For each material part, the part should furthermore be split
        # according to constant, linear and parabolic stress distribution.
        #   - For each part collect coordinates y and z in separate np.ndarray
        # iterables, and stress coefficients in a two-dimensional np.ndarray.
        #
        # The method should therefore return a tuple that collects the y, z,
        # and stress coefficients for each part.
        prepared_input = []
        # 1. Rotate section in order to have neutral axis horizontal
        angle = atan2(strain[2], strain[1])

        rotated_geom = geo.rotate(angle)
        # 2. Get y coordinate of neutral axis in this new CRS
        strain_rotated = [strain[0], (strain[2] ** 2 + strain[1] ** 2) ** 0.5]

        # 3. For each SurfaceGeometry on the CompoundGeometry:
        for g in rotated_geom.geometries:
            # 3a. get coefficients and strain limits from constitutive law
            if hasattr(g.material, '__marin__'):
                strains, coeffs = g.material.__marin__(strain_rotated)
            else:
                raise AttributeError(
                    f'The material object {g.material} of geometry {g} does \
                    not have implement the __marin__ function. \
                    Please implement the function or use another integrator, \
                    like '
                    'Fibre'
                    ''
                )

            # 3b. Subdivide the polygon at the different strain limits
            for p in range(len(strains)):
                # Create the two lines for selecting the needed part
                y0 = (strain_rotated[0] - strains[p][0]) / strain_rotated[1]
                y1 = (strain_rotated[0] - strains[p][1]) / strain_rotated[1]
                if y0 > y1:
                    y0, y1 = y1, y0
                bbox = g.polygon.bounds
                line0 = create_line_point_angle((0, y0), 0, bbox)
                line1 = create_line_point_angle((0, y1), 0, bbox)
                lines = MultiLineString((line0, line1))
                # intersection
                result = g.split_two_lines(lines=lines)

                def get_input_polygon(polygon, coeffs):
                    # Let's be sure to orient in the right way
                    if polygon.is_empty:
                        return
                    polygon = orient(polygon, 1)
                    if not polygon.exterior.is_ccw:
                        raise ValueError(
                            'The exterior of a polygon should have vertices \
                                         ordered ccw'
                        )
                    # Manage exterior part
                    x, y = polygon.exterior.coords.xy
                    x = np.array(x)
                    y = np.array(y)
                    prepared_input.append(
                        (0, np.array(x), np.array(y), np.array(coeffs))
                    )
                    # Manage holes
                    for i in polygon.interiors:
                        if i.is_ccw:
                            raise ValueError(
                                'A inner hole should have cw coordinates'
                            )
                        x, y = i.coords.xy
                        prepared_input.append(
                            (0, np.array(x), np.array(y), np.array(coeffs))
                        )

                if isinstance(result, Polygon):
                    # If the result is a single polygon
                    get_input_polygon(result, coeffs[p])
                elif isinstance(result, MultiPolygon):
                    # If the result is a MultiPolygon
                    for polygon in result.geoms:
                        get_input_polygon(polygon, coeffs[p])
        # Tentative proposal for managing reinforcement (PointGeometry)
        x = []
        y = []
        F = []
        for pg in rotated_geom.point_geometries:
            xp, yp = pg._point.coords.xy
            xp = xp[0]
            yp = yp[0]
            A = pg.area
            strain = strain_rotated[0] - strain_rotated[1] * yp
            x.append(xp)
            y.append(yp)
            F.append(pg.material.get_stress(strain)[0] * A)
        prepared_input.append((1, np.array(x), np.array(y), np.array(F)))

        return angle, prepared_input

    def integrate(
        self,
        angle: float,
        prepared_input: t.List[
            t.Tuple[int, np.ndarray, np.ndarray, np.ndarray]
        ],
    ) -> t.Tuple[float, float, float]:
        """Integrate stresses over the geometry."""
        # Set the stress resultants to zero
        N, Mx, My = 0.0, 0.0, 0.0

        # Loop through all parts of the section and add contributions
        for i, y, z, stress_coeff in prepared_input:
            if i == 0:
                # Find integration order from shape of stress coeff array
                n = stress_coeff.shape[0]

                # Calculate area moments
                area_moments_N = np.array(
                    [marin_integration(y, z, 0, k) for k in range(n)]
                )
                area_moments_Mx = np.array(
                    [marin_integration(y, z, 0, k + 1) for k in range(n)]
                )
                area_moments_My = np.array(
                    [marin_integration(y, z, 1, k) for k in range(n)]
                )

                # Calculate contributions to stress resultants
                N += sum(stress_coeff * area_moments_N)
                Mx += sum(stress_coeff * area_moments_Mx)
                My += sum(stress_coeff * area_moments_My)
            elif i == 1:
                # Reinforcement
                N += sum(stress_coeff)
                Mx += sum(stress_coeff * z)
                My += sum(stress_coeff * y)

        # Rotate back to section CRS
        T = np.array([[cos(angle), sin(angle)], [-sin(angle), cos(angle)]])
        M = T @ np.array([[Mx], [My]])

        return N, M[0, 0], M[1, 0]

    def integrate_strain_response_on_geometry(
        self, geo: CompoundGeometry, strain: ArrayLike, **kwargs
    ):
        """Integrate the strain response with the Marin algorithm."""
        del kwargs
        # Prepare the general input based on the geometry and the input strains
        angle, prepared_input = self.prepare_input(geo, strain)

        # Return the calculated response
        return *self.integrate(angle, prepared_input), None


class FiberIntegrator(SectionIntegrator):
    """Section integrator based on the Marin algorithm."""

    def prepare_triangulation(self, geo: SurfaceGeometry) -> t.Dict:
        """Triangulate a SurfaceGeometry object.

        Args:
            geo (SurfaceGeometry): The geometry to triangulate
        """
        # Create the tri dictionary
        tri: dict[str:ArrayLike] = {}
        # 1. External boundary process
        # 1a. Get vertices, skipping the last one
        vertices = np.stack(geo.polygon.exterior.xy, 1)[:-1, :]
        n_vertices = vertices.shape[0]
        # 1b. Create segments
        node_i = np.arange(n_vertices)
        node_j = np.roll(node_i, -1)
        segments = np.stack((node_i, node_j), 1)

        # 2. Process holes
        holes = []
        for interior in geo.polygon.interiors:
            # 2a. Get vertices, skipping the last one
            vertices_int = np.stack(interior.xy, 1)[:-1, :]
            n_vertices_int = vertices_int.shape[0]
            # 2b. Create segments
            node_i = np.arange(n_vertices_int) + n_vertices
            node_j = np.roll(node_i, -1)
            segments_int = np.stack((node_i, node_j), 1)
            c = Polygon(interior)
            holes.append([c.centroid.x, c.centroid.y])
            # Append to the global arrays
            vertices = np.vstack((vertices, vertices_int))
            segments = np.vstack((segments, segments_int))
            n_vertices += n_vertices_int
        # Return the dictionary with data for triangulate
        tri['vertices'] = vertices
        tri['segments'] = segments
        if len(holes) > 0:
            tri['holes'] = holes
        return tri

    def prepare_input(
        self, geo: CompoundGeometry, strain: ArrayLike, **kwargs
    ) -> t.Tuple[t.Tuple[np.ndarray, np.ndarray, np.ndarray]]:
        """Prepare general input to the integration.

        Calculate the stresses based on strains in a set of points.

        Args:
            geo (CompoundGeometry): The geometry of the section.
            strain (ArrayLike): The strains and curvatures of the section.
                                given in the format (ea, ky, kz) which are
                                strain at 0,0
                                curvature y axis
                                curvature z axis
            mesh_size: Percentage of area (number from 0 to 1) max for triangle
                        elements
        """
        # This method should:
        #  - discretize the section in a number of fibers (mesh_size)
        #  - prepare input as y coordiates z coordinates forces

        prepared_input = []

        triangulated_data = kwargs.get('tri', None)
        if triangulated_data is None:
            # No triangulation is provided, triangulate the section
            # Fiber integrator for generic section uses delaunay triangulation
            # for discretizing in fibers
            triangulated_data = []
            mesh_size = kwargs.get('mesh_size', 0.01)
            if mesh_size <= 0 or mesh_size > 1:
                raise ValueError('mesh_size is a number from 0 to 1')
            # For the surface geometries
            for g in geo.geometries:
                # prepare data structure for triangle module
                tri = self.prepare_triangulation(g)
                # define the maximum area of the triangles
                max_area = g.area * mesh_size
                # triangulate the geometry getting back the mesh
                mesh = triangle.triangulate(
                    tri, f'pq{30:.1f}Aa{max_area:.1f}o1'
                )
                mat = g.material
                # Get x and y coordinates (centroid) and area for each fiber
                x = []
                y = []
                area = []
                for tr in mesh['triangles']:
                    # get centroid of triangle
                    xc = (
                        mesh['vertices'][tr[0]][0]
                        + mesh['vertices'][tr[1]][0]
                        + mesh['vertices'][tr[2]][0]
                    )
                    xc /= 3.0
                    x.append(xc)
                    yc = (
                        mesh['vertices'][tr[0]][1]
                        + mesh['vertices'][tr[1]][1]
                        + mesh['vertices'][tr[2]][1]
                    )
                    yc /= 3.0
                    y.append(yc)
                    # compute area
                    a = (
                        mesh['vertices'][tr[0]][0] * mesh['vertices'][tr[1]][1]
                        - mesh['vertices'][tr[0]][1]
                        * mesh['vertices'][tr[1]][0]
                    )
                    a += (
                        mesh['vertices'][tr[1]][0] * mesh['vertices'][tr[2]][1]
                        - mesh['vertices'][tr[1]][1]
                        * mesh['vertices'][tr[2]][0]
                    )
                    a += (
                        mesh['vertices'][tr[2]][0] * mesh['vertices'][tr[0]][1]
                        - mesh['vertices'][tr[2]][1]
                        * mesh['vertices'][tr[0]][0]
                    )
                    a = abs(a) * 0.5
                    area.append(a)
                    # pointer to the material

                # return back the triangulation data
                triangulated_data.append(
                    (np.array(x), np.array(y), np.array(area), mat)
                )
            # For the reinforcement
            # Tentative proposal for managing reinforcement (PointGeometry)
            reinf_data = {}
            # Preprocess geometries having the same material
            for pg in geo.point_geometries:
                x, y = pg._point.coords.xy
                x = x[0]
                y = y[0]
                area = pg.area
                mat = pg.material
                if reinf_data.get(mat, None) is None:
                    reinf_data[mat] = [
                        np.array(x),
                        np.array(y),
                        np.array(area),
                    ]
                else:
                    reinf_data[mat][0] = np.hstack((reinf_data[mat][0], x))
                    reinf_data[mat][1] = np.hstack((reinf_data[mat][1], y))
                    reinf_data[mat][2] = np.hstack((reinf_data[mat][2], area))
            for mat, value in reinf_data.items():
                triangulated_data.append((value[0], value[1], value[2], mat))

        x = []
        y = []
        F = []
        for tr in triangulated_data:
            # All have the same material
            strains = strain[0] + strain[2] * tr[0] - strain[1] * tr[1]
            # compute stresses in all materials
            stresses = tr[3].get_stress(strains)
            x.append(tr[0])
            y.append(tr[1])
            F.append(stresses * tr[2])
        prepared_input = [(np.hstack(x), np.hstack(y), np.hstack(F))]

        return prepared_input, triangulated_data

    def integrate(
        self,
        prepared_input: t.List[
            t.Tuple[int, np.ndarray, np.ndarray, np.ndarray]
        ],
    ) -> t.Tuple[float, float, float]:
        """Integrate stresses over the geometry."""
        # Integration over all fibers
        x, y, F = prepared_input[0]

        N = np.sum(F)
        Mx = np.sum(F * y)
        My = np.sum(F * x)

        return N, Mx, My

    def integrate_strain_response_on_geometry(
        self, geo: CompoundGeometry, strain: ArrayLike, **kwargs
    ):
        """Integrate the strain response with the Marin algorithm."""
        # Prepare the general input based on the geometry and the input strains
        prepared_input, triangulated_data = self.prepare_input(
            geo, strain, **kwargs
        )

        # Return the calculated response
        return *self.integrate(prepared_input), triangulated_data


integrator_registry = {'Marin': MarinIntegrator, 'Fiber': FiberIntegrator}


class IntegratorFactory:
    """A factory for integrators."""

    instances: t.Dict  # A dict of integrators that have been created.
    registry: t.Dict[str, SectionIntegrator]

    def __init__(self, registry: t.Dict[str, SectionIntegrator]):
        self.instances = {}
        self.registry = registry

    def __call__(self, method: str) -> SectionIntegrator:
        """Create an integrator based on its name."""
        self.instances.setdefault(
            method, self.registry.get(method, MarinIntegrator)
        )
        # Here we should throw a warning if the user input an integrator not
        # given in the registry.
        return self.instances.get(method)


integrator_factory = IntegratorFactory(integrator_registry)
