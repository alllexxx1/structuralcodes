"""Classes for integrating the response of sections."""
import abc
import typing as t

import numpy as np
from numpy.typing import ArrayLike

from ._generic import CompoundGeometry
from ._marin_integration import marin_integration


class SectionIntegrator(abc.ABC):
    """Abstract base class for section integrators."""

    @abc.abstractmethod
    def prepare_input(self, geo: CompoundGeometry, strain: ArrayLike):
        """Prepare general input to the integration method.

        Args:
            geo (CompoundGeometry): The geometry to integrate over.
            strain (ArrayLike): The scalar strain components necessary for
                describing the assumed strain distribution over the geometry.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def integrate(self, *prepared_input, **kwargs) -> float:
        """Integrate stresses over the gemetry.

        The input to this method is generated by the prepare_input method. It
        also takes kwargs depending on the concrete implementation.

        Arguments:
            *prepared_input: The input prepared by the prepare_input method.

        Keyword Arguments:
            **kwargs: Keyword arguments depending on the concrete
                implementation.
        """
        raise NotImplementedError

    @abc.abstractmethod
    def integrate_strain_response_on_geometry(
        self, geo: CompoundGeometry, strain: ArrayLike
    ):
        """Integrate over the geometry to obtain the response due to strains."""
        raise NotImplementedError


class MarinIntegrator(SectionIntegrator):
    """Section integrator based on the Marin algorithm."""

    def prepare_input(
        self, geo: CompoundGeometry, strain: ArrayLike
    ) -> t.Tuple[t.Tuple[np.ndarray, np.ndarray, np.ndarray]]:
        """Prepare general input to the integration.

        Calculate the stresses based on strains in a set of points.

        Args:
            geo (CompoundGeometry): The geometry of the section.
            strain (ArrayLike): The strains and curvatures of the section.
        """
        # This method should do the following tasks:
        # - Split the compound geometry into parts according to materials.
        # - For each material part, the part should furthermore be split
        # according to constant, linear and parabolic stress distribution.
        # - For each part collect coordinates y and z in separate np.ndarray
        # iterables, and stress coefficients in a two-dimensional np.ndarray.
        #
        # The method should therefore return a tuple that collects the y, z,
        # and stress coefficients for each part.
        raise NotImplementedError

    def integrate(
        self,
        prepared_input: t.Tuple[t.Tuple[np.ndarray, np.ndarray, np.ndarray]],
    ) -> t.Tuple[float, float, float]:
        """Integrate stresses over the geometry."""
        # Set the stress resultants to zero
        N, Mx, My = 0.0, 0.0, 0.0

        # Loop through all parts of the section and add contributions
        for y, z, stress_coeff in prepared_input:
            # Find integration order from shape of stress coeff array
            m, n = stress_coeff.shape

            # Create stress coeff arrays for bending moments
            stress_coeff_mx = np.zeros(stress_coeff.shape)
            stress_coeff_mx[:, 1:] = stress_coeff[:, :-1]
            stress_coeff_my = np.zeros(stress_coeff.shape)
            stress_coeff_my[1:, :] = stress_coeff[:-1, :]

            # Calculate area moments
            area_moments = np.array(
                [
                    [marin_integration(y, z, j, k) for k in range(n)]
                    for j in range(m)
                ]
            )

            # Calculate contributions to stress resultants
            N += sum(sum(stress_coeff * area_moments))
            Mx += sum(sum(stress_coeff_mx * area_moments))
            My += sum(sum(stress_coeff_my * area_moments))

        return N, Mx, My

    def integrate_strain_response_on_geometry(
        self, geo: CompoundGeometry, strain: ArrayLike
    ):
        """Integrate the strain response with the Marin algorithm."""
        # Prepare the general input based on the geometry and the input strains
        prepared_input = self.prepare_input(geo, strain)

        # Return the calculated response
        return self.integrate(prepared_input)


integrator_registry = {'Marin': MarinIntegrator}


class IntegratorFactory:
    """A factory for integrators."""

    instances: t.Dict  # A dict of integrators that have been created.
    registry: t.Dict[str, SectionIntegrator]

    def __init__(self, registry: t.Dict[str, SectionIntegrator]):
        self.instances = {}
        self.registry = registry

    def __call__(self, method: str) -> SectionIntegrator:
        """Create an integrator based on its name."""
        self.instances.setdefault(
            method, self.registry.get(method, MarinIntegrator)
        )
        # Here we should throw a warning if the user input an integrator not
        # given in the registry.
        return self.instances.get(method)


integrator_factory = IntegratorFactory(integrator_registry)
